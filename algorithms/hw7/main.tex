\documentclass{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}   
\usepackage[english, russian]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
% \usepackage[left=1cm,right=1cm,top=1cm,bottom=1cm]{geometry}
\usepackage{hyperref}
\usepackage{seqsplit}
\usepackage[dvipsnames]{xcolor}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\usepackage{mathalfa}
\usepackage{mathrsfs}
\usepackage{dsfont}
\usepackage{caption,subcaption}
\usepackage{wrapfig}
\usepackage[stable]{footmisc}
\usepackage{indentfirst}
\usepackage{rotating}
\usepackage{pdflscape}

\usepackage{MnSymbol,wasysym}


\begin{document}

\title{\textbf{Основные алгоритмы. Домашняя работа 7 неделя}}


\author{Зайнуллин Амир}
\maketitle

\section*{Задача №1}

Для решение этой задачи можно использовать алгоритм двоичного поиска. Пусть $l$ - левый индекс массива, в котором может быть максимальный элемент, а $r$ - правая граница. 
Изначально $l = 0$, $r = n - 1$.

На каждом шаге будем узнавать значение элемента a[mid], a[mid + 1], где $mid = \dfrac{l + r}{2}$. 

Если a[mid] > a[mid + 1], то т.к массив строго унимодален, то максимальный элемент не может находиться в индексах mid + 1, ..., r. Тогда новые границы $l = l$, $r =$ mid. Отбросили половину границы. 

Если a[mid] < a[mid + 1], то т.к массив строго унимодален, то максимальный элемент не может находиться в индексах l, ... , mid. Тогда новые границы $l =$ mid + 1, $r = r$. Отбросили половину границы. 

Когда $l = r$, мы найдем наш максимальный элемент. 
Так как каждый раз мы делим наш промежуток пополам, то асимптотика алгоритма O(logn).

\section*{Задача 2-3}

Разобьем монеты на 3 группы следующим образом. 

Если n делится на 3, то в каждой группе по $n / 3$ элементов. 

Если n дает остаток 1 при делении на три, то будет две группы по $\lfloor n/3\rfloor$ монет и одна $\lfloor n/3\rfloor + 1$. 

Если n дает остаток 2 при делении на три, то будет две группы по $\lfloor n/3\rfloor + 1$ и одна $\lfloor n/3\rfloor$.

Далее берем две группы с одинаковым количеством монет и сравниваем их массу. Если она одинакова, фальшивая находится в третьей группе. Выбираем ее. Если масса разная, то выбираем ту, которая легче, так как фальшивая легче обычной. 

Далее повторяем алгоритм для выбранной группы (так же делить на три группы и т.д). Заметим, что за каждое взвешивание группа, в которой мы ищем фальшивую монету уменьшается в три раза. Значит фальшивую монету можем найти за $log_3(n) + c$. Константа $c$ появляется потому что количество элементов в группе не всегда может делиться на три.

Рассмотрим разрешающее дерево этой функции. Количество листьев в разрешающем дереве равно n (информация, какая монета является фальшивой). Допустим мы сделали $x = log_3(n)$ взвешиваний. Тогда глубина дерева равна $x$, и количество листьев $3 ^ h < n$. Противоречие.

\section*{Задача 4-5}

Разобьем монеты на $\lfloor n/2\rfloor$. Будем взвешивать каждую пару монет. Если их вес одинаковый, то обе не фальшивые. Если нет, то та которая легче есть фальшивая. Если n - нечетно, то если все пары оказались не фальшивыми, то монета, которая оказалась без пары - фальшивая.

Воспользуеся методом игры с противником для доказательства того что для нахождения фальшивой монеты необходимо $\lfloor n/2\rfloor$ взвешиваний.

Оставим фальшивую монету в последней паре. Если мы сделали меньше $\lfloor n/2\rfloor$ взвешиваний, то у нас осталось 2 монеты, если n четно, и 3 монеты если n нечетно. Какую монету мы бы не выбрали, методом игры с противником можно сделать так, что игрок не найдет фальшивую монету за меньше чем $\lfloor n/2\rfloor$ ходов. 


\newpage
\section*{Задача 6}

Так как на вход задачи подаются \textbf{натуральные числа} $n, a_0, \ldots a_n$ и $y$ и мы смотрим в натуральной точке, то многочлен 
\[ a_n x^n + a_{n-1} x^{n-1} + \ldots + a_1x +  a_0 \] 
будет строго возрастать, так как его производная 
\[ a_n n x^{n - 1} + a_{n-1} (n - 1) x^{n-2} + \ldots + a_1 > 0 \] 
Значит мы можем воспользоваться бинарным поиском. Изначально $ l = 1 $, $ r = y$, потому что при $x = y$ многочлен будет точно больше $y$. Если значение многочлена при $x = l$ больше $y$, то такой ответа нет. Аналогично если при $x = r$ значение многочлена меньше $y$, ответа нет.

Пусть $mid = \dfrac{l + r}{2}$. Если $P(mid) > y$, то продолжаем поиск в левой части. $l = l$, $r = mid$. 

Если $P(mid) < y$, то продолжаем поиск в правой части. $l = mid$, $r = r$. Когда $r$ и $l$ совпадут, и значение в этой точке не будет равно y, значит ответа нет. Иначе мы нашли ответ за $\log y$. 

\section*{Задача 7}


\end{document}